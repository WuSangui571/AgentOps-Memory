# AgentOps-Memory

> 让 AI 智能体像“有长期记忆、守工程纪律、不会重复造轮子”的工程师一样写代码。  
> A lightweight, repo-native workflow & memory system for AI coding agents.

---

## 为什么会有这个项目？

随着 Codex / Claude / Gemini / Cursor 等 AI 智能体的普及，开发效率被显著放大。但同时，很多工程团队也遇到了一类共同的问题：

### ✅ 1) AI 缺乏“项目级长期记忆”
AI 很擅长“局部写代码”，但常常缺乏人类工程师那种对仓库整体的稳定认知，例如：

- 同一个业务被写出两套接口（重复造轮子）
- 忘记已有的模块边界和约束
- 命名漂移、架构漂移
- 只关注当前任务，忽视历史变更与约定
- 写得快但难维护、难演进

### ✅ 2) Prompt 不够，真正需要的是「上下文工程 + 工作流工程」

很多人以为未来比拼的是“提示词”，但在真实工程中，决定结果的往往是：

- 是否有稳定的开发流程（SOP）
- 是否有可检索的项目记忆（Memory）
- 是否有强制的自检机制（Checklists）
- 是否有持续的变更留痕（Changelog）

**AgentOps-Memory** 的目标就是把这些能力变成一套轻量、通用、可复制的仓库内体系——  
无需依赖外部系统，不绑定某个模型，不限制某个 IDE。

---

## 你会得到什么？

使用本体系后，你可以显著降低以下问题发生概率：

- ✅ 同业务重复接口 / 重复 Service / 重复工具函数
- ✅ 新功能写错位置、破坏模块边界
- ✅ 忘记旧约定导致兼容性问题
- ✅ 没有留痕导致后续改动越改越乱
- ✅ AI 输出看似正确但存在明显语法、导入、字段不一致等静态错误

同时，你会逐步沉淀一套：

> **“AI 可以稳定复用、团队可以持续迭代”的工程资产。**

---

## 适用场景

- 本地智能体 / IDE 智能体（Codex、Cursor、Copilot、Claude、Gemini…）
- 单人项目或团队项目
- 前端 / 后端 / 全栈 / 脚本 / 工具库
- 任何希望 AI 参与真实改动的仓库

---

## 快速开始（推荐用法）

### Step 1：在仓库根目录创建 `.ai/` 并放入 5 个文件

+ README.md
+ SOP_AGENT.md
+ PROJECT_MEMORY.md
+ CHECKLISTS.md
+ CHANGELOG_AI.md

### Step 2：把下面这段作为「开场提示词」，每次对话第一条发给 AI

> ✅ 强烈建议你把这段保存为 IDE 的 “Project Rules / System Prompt / 初始指令”。

```md
请先阅读本仓库的 `.ai/README.md`，并严格遵守其中的所有规则与工作流程。
任何新增接口/模块前必须先检索并输出检索报告，禁止重复造轮子。
开始前先完成：项目扫描 → 需求复述 → 验收标准 → 检索报告 → 复用/新建决策，再开始写代码。
```

这条指令的关键点是：**它让 AI 自己去读仓库规则，而不是每次你复制一大坨 Prompt。**

## 工作流概览（你可以理解为“AI 开发纪律”）

每次任务都遵循：

1. **项目扫描**：检索并阅读入口/核心实现/配置/历史修改记录
2. **复述需求 + 验收标准**：防止跑偏
3. **检索优先（Retrieve-first）**：找已有实现并给出复用策略
4. **复用 > 修改 > 新建**：禁止同业务双实现
5. **编码（小步可回滚）**：保持风格一致
6. **提交前自检（Checklists）**：避免静态错误与架构漂移
7. **变更留痕（Changelog）**：沉淀“短期记忆增量”
8. **必要时更新长期记忆（Project Memory）**

------

## `.ai/` 文件说明（按重要性排序）

> 你可以把 `.ai/` 理解为：**AI 的项目大脑（Repo-native Brain）**。

### 1) `.ai/README.md`（入口规则 / 开工指令，最高优先级）

这是 AI 进入仓库时必须阅读的“项目规则”，包含：

- 强制约束（不得臆测、检索优先、复用优先、禁止重复实现等）
- 工作流程（从需求理解到交付）
- 输出格式（确保交付一致性）
- 文档留痕规则（CHANGELOG & Memory 更新）

📌 **建议**：你以后只需要说一句「先读 `.ai/README.md`」，让 AI 自己按规矩来。

------

### 2) `.ai/SOP_AGENT.md`（AI 智能体开发 SOP）

这是 AI 的“工作说明书”，规定每次任务必须走的流程：

- 需求理解与验收标准
- 检索优先（retrieve-first）
- 复用/新建决策标准
- 编码与改动最小化原则
- 提交前检查要求
- 文档留痕要求

📌 **价值**：让 AI 输出稳定、可预测，而不是每次随机发挥。

------

### 3) `.ai/PROJECT_MEMORY.md`（项目长期记忆 / 稳定事实）

这是 AI 的“长期记忆载体”，记录：

- 业务域与模块边界
- 必须复用的关键接口/服务索引
- 数据模型与核心约束
- 命名规范、错误处理、日志规范
- 已知坑点与注意事项

📌 **价值**：显著降低 AI 重复造轮子、改错位置、写错接口字段等问题。

------

### 4) `.ai/CHECKLISTS.md`（提交前自检清单）

这是 AI 的“防翻车清单”，用于提交前静态自检：

- 是否检索过？
- 是否可能重复实现？
- 是否破坏模块边界？
- 是否存在明显语法/导入/字段/路径错误？
- 是否更新了日志与记忆文档？

📌 **价值**：降低“看起来很对但其实不能跑”的概率，提升交付可靠性。

------

### 5) `.ai/CHANGELOG_AI.md`（AI 修改日志 / 记忆增量）

这是 AI 的“短期记忆补丁”，记录每次由 AI 参与的改动：

- 背景/需求
- 修改摘要与涉及文件
- 检索与复用策略（为什么改旧的不新写）
- 风险点与验证方式
- 后续建议

📌 **价值**：让后续 AI（或人类）能快速理解最近变更，避免重复踩坑与二次造轮子。

------

## 最佳实践（强烈推荐）

### ✅ 1) 把“检索报告”变成强制交付项

AI 只要不写检索报告，就不让它进入编码阶段。
 这是避免重复接口的最强手段。

### ✅ 2) 用“双智能体制”（可选但效果极强）

- Builder Agent：写代码
- Reviewer Agent：只按 CHECKLISTS.md 检查并挑错

这能把质量提升一个数量级。

### ✅ 3) 把项目的关键事实写入 PROJECT_MEMORY

不要写流水账，写“稳定事实 + 约束 + 索引”。

------

## 常见问题（FAQ）

### Q：这套体系和 Prompt Engineering 有什么区别？

A：Prompt 是一句话技巧，而本体系是工程制度化：
 **Context Engineering（上下文工程） + Workflow Engineering（工作流工程） + Code Governance（代码治理）**

### Q：一定要 5 个文件吗？

A：最小可用只需要 3 个：

- `.ai/README.md`
- `.ai/SOP_AGENT.md`
- `.ai/CHECKLISTS.md`
   但要解决“长期记忆”和“历史变更”，`PROJECT_MEMORY` 和 `CHANGELOG_AI` 非常关键。

### Q：适用于团队吗？

A：非常适用。团队使用时，建议把 `.ai/README.md` 纳入 code review 规则，强制执行。

------

## 致谢 / 背景

本项目来自真实开发实践：当 AI 写代码速度越来越快，“工程一致性”和“长期可维护性”会成为真正的差异来源。

如果你觉得这套体系对你有帮助，欢迎 Star / Fork / 提 PR 共同完善。